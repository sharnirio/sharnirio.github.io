/*«Если элемент является ссылкой, у него должен быть атрибут href»*/

a:not([href]):after {
   content: 'Это должна быть ссылка или кнопка? Она никуда не ведёт!';
   display: block !important;
   background: pink !important;
   padding: 0.5em !important;
   font-family: 'comic sans ms', cursive !important;
   color: #000 !important;
   font-size: 16px !important;
}

/*Примечание: В этом примере мы проверяем не значение атрибута, а само существование атрибута, т.е. соответствует ли
условию [href] элемент, у которого есть атрибут href. Эта проверка должна осуществляться только для гиперссылок, для
этого используется префикс a. Правило можно прочитать так: «Для каждого элемента a, который не содержит атрибут [href],
должен быть добавлен псевдо- контент с сообщением об ошибке.*/



/*«Если элемент является ссылкой и содержит атрибут href, у него должно быть валидное значение»*/

a[href=""]:after, a[href$="#"]:after, a[href^="javascript"]:after {
   content: 'Эта ссылка должна быть кнопкой? Она никуда не ведёт!';
   /*… уродливый стиль …*/
}

/*Примечание: Если href пуст, заканчивается символом # или в нем /*используется JavaScript, скорее всего мы имеем дело с
кнопкой, для /*которой не используется правильный элемент button. Обратите /*внимание, что я использую формулировку
«начинается с javascript». /*Обычно чтобы оставить href пустым пишут javascript:void(0), но мы не /*можем рассчитывать
что так прописано во всех случаях без исключения /*(возможно отсутствие или присутствие пробела после двоеточия,
/*например).*/



/*«Если используется класс button, то элемент должен быть кнопкой, по крайней мере с точки зрения доступности»*/

.button:not(button):not([role="button"]):not([type="button"]):not([type="submit"]):not([type="reset"]):after,
.btn:not(button):not([role="button"]):not([type="button"]):not([type="submit"]):not([type="reset"]):after,
a[class*="button"]:not([role="button"]):after {
   content: 'Если вы хотите чтобы этот элемент выглядел как кнопка, сделайте его кнопкой, черт побери!';
   /*… уродливый стиль …*/
}

/*Примечание: В этом примере мы демонстрируем как можно составить цепочку отрицаний проводя проверку атрибутов. Каждый
/*селектор читается так: «Если для элемента применён класс указывающий на то, что перед нами кнопка, но это не элемент
/*button, и для него не указана соответствующая роль, чтобы он был кнопкой с точки зрения доступности, если это не
/*input, который используется как кнопка, значит… кое-кто врёт». Мне пришлось использовать [class*="button"] чтобы
/*уловить множество разновидностей классов на Topcoat (всего 62!), которые не подходят для превращения ссылки в
/*настоящую кнопку. Я заметил, что некоторые разработчики используют button-container и ему подобные для родительских
/*контейнеров, потому добавил оговорку a чтобы избежать некорректных результатов. Вы можете признавать класс .btn,
/*который используется в Twitter Bootstrap, однако вы должны знать (если внимательно читали документацию) что являются
/*ли ссылки или кнопки кнопками при его использовании — спорный вопрос.*/




/*«Если для элемента указано role="button", он должен на что-либо ссылаться при отключённом JavaScript»*/

a[role="button"]:not([href*="/"]):not([href*="."]):not([href*="?"]):after {
   content: 'Используйте резервную ссылку или элемент button.';
   /*… уродливый стиль …*/
}

/*Примечание: Можно быть вполне уверенным, что если href не содержит /, . (обычно перед расширением файла) или ? (начало
/*строки запроса), скорее всего он липовый. Если вы хотите, чтобы ссылки вели себя как кнопки и возвращали return: false
/*когда JavaScript включён — ладно, но когда JavaScript отключён они должны вести на какую-то страницу. Кстати, это
/*единственная уважительная причина, чтобы не использовать вместо ссылки <button>.*/


/*«Гиперссылку нельзя отключить»*/

a.button[class*="disabled"]:after,
a.btn.disabled:after,
a[class*="button"][class*="disabled"]:after {
   content: 'Ссылки нельзя отключать. Используйте элемент button с disabled="disabled".';
   /*… уродливый стиль …*/
}

/*Примечание: Даже старые браузеры понимают атрибут disabled, так что используйте его с подходящим элементом в
/*соответствии со стандартами. Для атрибутов можно применять конкатенацию точно так же как для классов: в части с
/*последними тремя селекторами говорится: «Если мы имеем дело с ссылкой, которая содержит подстроку button и подстроку
/*disabled, должно быть выведено сообщение об ошибке». В таблице стилей Twitter Bootstrap используется вторая форма,
/*.btn.disabled, но не с префиксом a. Ошибкой считается только использование disabled для ссылок.*/



/*«У кнопок в формах должен быть прямо указан тип ввода»*/


form button:not([type]):after {
  content: 'Это кнопка отправки информации, кнопка обнуления полей или что? Используйте type="submit", type="reset" или type="button"';
}

/*Примечание: Нам нужно определить указан ли тип ввода для кнопок в формах потому что в таком контексте без чётко
/*указанного типа некоторые браузеры интерпретируют кнопки как type="submit". Мы должны быть полностью уверены, что
/*кнопке не будет присвоена функция отправки информации на сервер если она должна отвечать за какое-либо другое
/*действие.*/

/*«И ссылки, и кнопки должны содержать какой-либо контент или ARIA- метку»*/

a:empty:not([aria-label]):not([aria-labelledby]):after,
button:empty:not([aria-label]):not([aria-labelledby]):after,
button:not([aria-label]):not([aria-labelledby]) img:only-child:not([alt]):after,
a:not([aria-label]):not([aria-labelledby]) img:only-child:not([alt]):after {
   content: 'Все кнопки и ссылки должны содержать текстовый контент, изображение с текстом alt или метку ARIA';
   /*… уродливый стиль …*/
}

/*Примечание: Кнопки и ссылки, которые не содержат никакой информации о своём предназначении (в текстовой или
/*графической форме) являются неправильными. Последние два селектора наверное самые сложные из всех, которые я когда-
/*либо написал. В версии для ссылки селектор можно прочитать как-то так: «Если мы имеем дело с ссылкой, которая не имеет
/*атрибут aria-label или aria-labelledby и содержит только изображение в качестве содержимого, но у этого изображения
/*нет атрибута alt, нужно вывести уведомление об ошибке.» Также обратите внимание на использование селектора :empty.
/*Можно утверждать что парные теги не должны оставаться пустыми.

Аплодисменты тому, кто первым используя revenge.css обнаружит где я нарушил своё же правило описанное в этой статье.
Поверьте, ошибка имеет место без сомнений.*/

